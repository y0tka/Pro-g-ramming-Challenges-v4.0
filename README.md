# Pro`/g/`ramming Challenges, v4.0

![](pages/image.png)

## Tasks

### Practical

- [ ] Markov Chain Sentence Generator `(4)`
- [ ] To-Do List Application (Web app or CLI) `(10)`
- [ ] Chatbot (with conversation retention) `(15)`
- [x] Image to ASCII Art `(18)`
- [ ] Imageboard (Imagine vichan) `(25)`
- [ ] Create an HSV Color Representation `(35)`
- [ ] Port Scanner `(42)`
- [ ] Old School Demo Effect (Plasma, Tunnel, Scrollers, Zoomers, etc..) `(43)`

---

### Algorithm

- [ ] Fizzbuzz (BOUNS: In Assembly) `(44)`
- [ ] RPN Calculator `(45)`
- [ ] Counts occurrences of characters in a Given String (include support for unicode characters) `(46)`
- [ ] Tower of Hanoi `(47)`
- [ ] Calculate the first (n) digits of pi `(50)`
- [ ] Given an Array of Stocks' values over time, find the period of time where stocks could have made the money `(52)`
- [ ] Hightest Prime Factor Calculator `(53)`
- [ ] Password Generator (Let User Choose Options) `(56)`
- [ ] Caesar Cipher Cracker `(59)`
- [ ] ROT 13 `(61)`
- [ ] Encrypt/Decrypt Text: Implement at least one from https://rumkin.com/tools/cipher/collection `(64)`
- [ ] Youtube to MP3 `(65)`
- [ ] Text to Hexadecimal/Binary `(66)`
- [ ] Sierpinski Triangle `(68)`

---

### Emulation/Modeling

- [ ] Generate a Complimentary Color from any input color `(96)`
- [ ] *Generate a 5-Color Scheme from the most dominant tones in any image* `(97)`
- [ ] Eulerian Path `(101)`
- [ ] Draw a spinning 3D Cube `(102)`
- [ ] Cellular Textures `(103)`
- [ ] ASCII Digital Clock `(145)`

---

## HOW-TO Guide

0. **Use git and an eternal website to push on**  
Learn to use git and commit early and often. Optionally, use a website to push your work to (such as GitHub). **The most important thing is to build a portfolio.**

1. **Understand the problem**  
Do your own research. It's an incredibly useful kill which can be applied to and can be applied to anything else. If a problem seems difficult, good! Draw it out, write it out, do whatever you need to do to solve it If the problem you're solving is too easy, brainstorm and try adding additional functionality. Try combining it with other ideas to make your software more challenging.

2. **Implementation**  
Take the language you're most familiar with to start your project. If the problem is too easy, pick a language you've never used. Don't be afraid to write awful code and don't worry about the best implementation. Get a working implementation first, then refactor and clean it up.

3. **Test**  
Write test cases for your program. Get used to thinking about how you can break your software. Find problems, bugs, and fix them. Repeat over and over again and document it. Throw it together in your portfolio (don't forget to commit!).

4. **Re-Implement**  
Now that you have something together with lots of documentation and experience, try a different language and try to match it as closely as possible to your first implementation. Add features, try new techniques, new styles. Go crazy!

5. **Don't stop learning**  
Now that you've gotten this far, don't stop trying to challenge yourself. Keep a portfolio/blog/diary and keep adding to it.

6. Resources: **Wikipedia, Stack Overflow and Google**  
Seriously, this is all you'll ever need. If you aren't getting results, you aren't doing your research properly. With these three websites, you'll find your answers. If they don't exist, make a thread. By doing so, you help other people out too! Remember: if you make a new topic for a new problem anywhere, write down the solution if someone PM'd you. It helps people a lot and encourages them to do the same.

7. Literature:
	- Knuth: *The Art of Computer Programming*
	- Siena: *The Algorithm Design Manual*
	- Carmen et al: *Introduction to Algorithms*
	- Russel: *Artificial Intelligence: A Modern Approach*
	- Abel son: *Structure and Interpretation of Computer Programs*

8. Hungry for More?  
Below is a s small list of websites that contain additional challenges:
- www.hackerrank.com
- www.codechef.com
- www.codefights.com
- www.projecteuler.net - Math Problems with a focus on programming and algorithmic efficiency
- www.rosettacode.org 
- www.codeabbey.com
- www.codingbat.com
- www.programmingpraxis.com
